#! /usr/bin/python
# -*- coding: latin-1 -*-
# $Id$
"""
A script meant to make the job of analyzing the TTPD log files easier.


Copyright (C) 2004 by Martin Thorsen Ranang
"""

__version__ = "$Rev$"
__author__ = "Martin Thorsen Ranang"

import optparse
import re
import time
import datetime

import TTP.Options
import TTP.LogHandler

option_list = []

billing_re = re.compile('^%s ttpd INFO \[[0-9a-f]*\] ' \
                        'billing=(?P<billing>\d+) (?P<interface>\S+) ' \
                        '\((?P<host>[^,]+), (?P<trans_type>\w+)\) ' \
                        '(?P<what>\w+)$'
                        % (TTP.LogHandler.log_line_re_date))

resolutions = {
    'hours':
    ('%s Hour %02d',
     (lambda t: (t.date(), t.time().hour))),
    'days':
    ('Day %s',
     (lambda t: t.date())),
    'weeks':
    ('%d Week %02d',
     (lambda t: (t.year, t.isocalendar()[1]))),
    'months':
    ('%d Month %02d',
     (lambda t: (t.year, t.month))),
    'years':
    ('Year %d',
     (lambda t: t.year))
    }

ttpd_analyze_options = [
    (['-F', '--filter-only'],
     {'dest': 'filter_only',
      'default': False,
      'action': 'store_true',
      'help': 'if this flag is given, the program will only return a ' \
      'filtered list of "billing lines"'}),
    (['-c', '--cost'],
     {'dest': 'cost',
      'default': False,
      'action': 'store_true',
      'help': 'if this flag is given, the output is cost based ' \
      'instead of transaction based; the default is ' \
      'transaction based'}),
    (['-r', '--resolution'],
     {'dest': 'resolution',
      'default': 'weeks',
      'metavar': 'TIME_UNITS',
      'help': "duration of TIME_UNITS for each temporal grouping; " \
      "available values are %s; the default is '%%(default)s'" %
      (', '.join(["'%s'" % x for x in resolutions]))}),
    (['-g', '--group-by'],
     {'dest': 'group_by',
      'default': 'interface,host,trans_type',
      'metavar': 'GROUPS',
      'help': "the GROUPS of the groupings used; available values are %s; " \
      "the default is %%(default)s" %
      (', '.join(["'%s'" % x for x in billing_re.groupindex]))})]

def file_filter(options, filename):
    
    """ Parse a log file and return the necessary information. """
    
    file = open(filename, 'r')
    for line in file:
        m = billing_re.match(line)
        if m:
            yield m.groupdict() #m.groups()

    file.close()

def format_trans(trans, reparsable = True):
    
    if reparsable:
        return '%(date_str)s ttpd INFO [] billing=%(billing)d ' \
               '%(interface)s (%(host)s, ' \
               '%(trans_type)s) %(what)s' % trans
    else:
        return '%(date_str)s, %(billing)d, %(interface)s, %(host)s, ' \
               '%(trans_type)s, %(what)s' % trans

def convert_types(trans):

    trans['date_str'] = trans['date']
    trans['date'] = time.strptime(trans['date'], '%Y-%m-%d %H:%M:%S')
    trans['billing'] = int(trans['billing'])

def group_by(set, groups, extract_discriminators):
    
    for element in set:

        group = extract_discriminators(element)
        
        if group not in groups:
            groups[group] = [element]
        else:
            groups[group].append(element)

    return groups

def main():
    
    """ Module mainline (for standalone execution). """
    
    parser = optparse.OptionParser(usage = '%prog [options] [file] [file] ...',
                                   version = '%%prog version %s' %
                                   (__version__))
    
    for option, description in ttpd_analyze_options:
        TTP.Options.update_help(description)
        parser.add_option(*option, **description)
        
    options, args = parser.parse_args()

    options.group_by = options.group_by.split(',')
    
    T = []
    
    for file in args:
        lines = file_filter(options, file)
        
        for trans in lines:
            convert_types(trans)
            
            if options.filter_only:
                print format_trans(trans)
                continue
            
            T.append(trans)

    if options.filter_only:
        return

    groups = {}

    # Create the temporal groups, dependent of options.resolution.
    
    for trans in T:
        dt = datetime.datetime(*trans['date'][:6])
        unit = resolutions[options.resolution][1](dt)
        if unit not in groups:
            groups[unit] = [trans]
        else:
            groups[unit].append(trans)

    units = groups.keys()
    units.sort()
    
    for unit in units:
        print resolutions[options.resolution][0] % unit

        subgroups = {}
        
        for trans in groups[unit]:
            subunit = tuple([trans[key] for key in options.group_by])
            if subunit not in subgroups:
                subgroups[subunit] = [trans]
            else:
                subgroups[subunit].append(trans)
                
            #print '\t', format_trans(trans)

        #print subgroups
        subunits = subgroups.keys()
        subunits.sort()

        for subunit in subunits:

            billing = 0
            
            for trans in subgroups[subunit]:
                #print format_trans(trans)
                if options.cost:
                    billing += trans['billing']
                else:
                    billing += 1

            print '%s:\t%d' % (subunit, billing)

                
    return


if __name__ == "__main__":
    main()
