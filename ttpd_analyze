#! /usr/bin/python
# -*- coding: latin-1 -*-
# $Id$
"""
A script meant to make the job of analyzing the TTPD log files easier.


Copyright (C) 2004 by Martin Thorsen Ranang
"""

__version__ = "$Rev$"
__author__ = "Martin Thorsen Ranang"

import optparse
import re
import time
import datetime

import TTP.Options
import TTP.LogHandler

option_list = []

billing_re = re.compile('^%s ttpd INFO \[[0-9a-f]*\] ' \
                        'billing=(?P<billing>\d+) (?P<interface>\S+) ' \
                        '\((?P<host>[^,]+), (?P<trans_type>\w+)\) ' \
                        '(?P<what>\w+)$'
                        % (TTP.LogHandler.log_line_re_date))

resolutions = {
    'hours':
    ('%s Hour %02d',
     (lambda t: (t.date(), t.time().hour))),
    'days':
    ('Day %s',
     (lambda t: t.date())),
    'weeks':
    ('%d Week %02d',
     (lambda t: (t.year, t.isocalendar()[1]))),
    'months':
    ('%d Month %02d',
     (lambda t: (t.year, t.month))),
    'years':
    ('Year %d',
     (lambda t: t.year))
    }

ttpd_analyze_options = [
    (['-F', '--filter-only'],
     {'dest': 'filter_only',
      'default': False,
      'action': 'store_true',
      'help': 'if this flag is given, the program will only return a ' \
      'filtered list of "billing lines"'}),
    (['-c', '--cost'],
     {'dest': 'cost',
      'default': False,
      'action': 'store_true',
      'help': 'if this flag is given, the output is cost based ' \
      'instead of transaction based; the default is ' \
      'transaction based'}),
    (['-r', '--resolution'],
     {'dest': 'resolution',
      'default': 'weeks',
      'metavar': 'TIME_UNITS',
      'help': "duration of TIME_UNITS for each temporal grouping; " \
      "available values are %s; the default is '%%(default)s'" %
      (', '.join(["'%s'" % x for x in resolutions]))}),
    (['-m', '--averages-for'], # FIXEM: Maybe 'units' would match 'resolution'?
     {'dest': 'averages_for',
      'default': 'day_of_week',
      'metavar': 'TIME_UNITS',
      'help': "duration of TIME_UNITS for each temporal grouping; " \
      "available values are %s; the default is '%%(default)s'" %
      (', '.join(["'%s'" % x for x in resolutions]))}),
    (['-f', '--from'],
     {'dest': 'start',
      'default': False,
      'metavar': 'DATE',
      'help': "Only consider entries including and later than DATE"}),
    (['-t', '--to'],
     {'dest': 'end',
      'default': False,
      'metavar': 'DATE',
      'help': "Only consider entries up to and including DATE"}),
    (['-g', '--group-by'],
     {'dest': 'group_by',
      'default': 'interface,host,trans_type',
      'metavar': 'FIELD,FIELD,...',
      'help': "the FIELDS used to discriminate between groups used; " \
      "available values are %s; the default is %%(default)s" %
      (', '.join(["'%s'" % x for x in billing_re.groupindex]))}),
    (['-R', '--restrict-to'],
     {'dest': 'restrict_to',
      'default': {},
      'metavar': 'FIELD=VALUE,FIELD=VALUE,...',
      'help': "the FIELD and value pairs used to restrict the output; " \
      "only groups fulfilling the criteria are output"})]


def file_filter(options, filename):
    
    """ Parse a log file and return the necessary information. """
    
    file = open(filename, 'r')
    for line in file:
        m = billing_re.match(line)
        if m:
            yield m.groupdict() #m.groups()

    file.close()

def format_trans(trans, reparsable = True):
    
    if reparsable:
        return '%(date_str)s ttpd INFO [] billing=%(billing)d ' \
               '%(interface)s (%(host)s, ' \
               '%(trans_type)s) %(what)s' % trans
    else:
        return '%(date_str)s, %(billing)d, %(interface)s, %(host)s, ' \
               '%(trans_type)s, %(what)s' % trans

def convert_types(trans):

    trans['date_str'] = trans['date']
    tmp = time.strptime(trans['date'], '%Y-%m-%d %H:%M:%S')
    trans['date'] = datetime.datetime(*tmp[:6])
    trans['billing'] = int(trans['billing'])

def group_by(extract_discriminators, set):
    
    groups = {}
    
    for element in set:
        group = extract_discriminators(element)
        if group not in groups:
            groups[group] = [element]
        else:
            groups[group].append(element)

    return groups

def main():
    
    """ Module mainline (for standalone execution). """
    
    parser = optparse.OptionParser(usage = '%prog [options] [file] [file] ...',
                                   version = '%%prog version %s' %
                                   (__version__))
    
    for option, description in ttpd_analyze_options:
        TTP.Options.update_help(description)
        parser.add_option(*option, **description)
        
    options, args = parser.parse_args()
    
    options.group_by = options.group_by.split(',')
    if options.restrict_to:
        options.restrict_to = dict([tuple(x.split('='))
                                    for x in options.restrict_to.split(',')])

    for moment, default in [('start', datetime.date.min),
                            ('end', datetime.date.max)]:
        if getattr(options, moment):
            setattr(options, moment,
                    datetime.date(*time.strptime(getattr(options, moment),
                                                 '%Y-%m-%d')[:3]))
        else:
            setattr(options, moment, default)
            
    transactions = []

    # Add the contents of each file.
    
    for file in args:
        lines = file_filter(options, file)
        
        for trans in lines:
            convert_types(trans)

            if trans['date'] < options.start or options.end < trans['date']:
                continue
            
            if options.filter_only:
                print format_trans(trans)
                continue
            
            transactions.append(trans)

    if options.filter_only:
        return

    # Create the temporal groups, dependent of options.resolution.
    
    groups = group_by(lambda x:
                      resolutions[options.resolution][1](x['date']),
                      transactions)

    #print groups
    
    units = groups.keys()
    units.sort()
    
    for unit in units:
        print resolutions[options.resolution][0] % unit
        
        subgroups = group_by(lambda x:
                             tuple([x[key] for key in options.group_by]),
                             groups[unit])
        
        subunits = subgroups.keys()
        subunits.sort()

        for subunit in subunits:

            billing = 0
            
            for trans in subgroups[subunit]:
                #print format_trans(trans)
                if options.cost:
                    billing += trans['billing']
                else:
                    billing += 1
                    
            for i, field in enumerate(options.group_by):
                if field in options.restrict_to and \
                       options.restrict_to[field] != subunit[i]:
                    break
            else:
                print '%s:\t%d' % (subunit, billing)

                
    return


if __name__ == "__main__":
    main()
