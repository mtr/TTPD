#! /usr/bin/python -OO
# -*- coding: latin-1 -*-
# $Id$
"""
TUC Transfer Protocol Client (TTPC).

The TTPC makes it easy to test the TTPD and to create interfaces that
interacts with the TTPD.

Copyright (C) 2004 by Martin Thorsen Ranang
"""

__version__ = "$Rev$"
__author__ = "Martin Thorsen Ranang"

import commands
import cStringIO
import logging
import optparse
import os
import sys
import time
import xml.sax

import TTP.Message

import locale

    
def parse_command_line():
    
    """ Parse the command line options. """
    
    basename = os.path.basename(sys.argv[0])
    
    parser = optparse.OptionParser(usage = '%prog [options] [request]',
                                   version = '%%prog %s' % (__version__))

    parser.add_option('-I', '--transaction-id', dest = 'trans_id',
                      help = 'the TRANS_ID to use when communicating with ' \
                      'a remote server. Default is LINGSMSOUT.',
                      metavar = 'TRANS_ID', default = 'LINGSMSOUT')
    
    parser.add_option('-a', '--ip-address', dest = 'ip_address',
                      help = 'the ADDRESS of the interface on which ' \
                      'to listen for connections from clients; ' \
                      'if ADDRESS is 0 (the default) the server will ' \
                      'listen on all available network interfaces.',
                      metavar = 'ADDRESS', default = '0')
    
    parser.add_option('-p', '--port', dest = 'port',
                      help = 'listen for connections from clients on PORT;' \
                      'the default is 2005.', type = 'int', default = 2005,
                      metavar = 'PORT')
    
    parser.add_option('-Q', '--high-load-limit', dest='high_load_limit',
                      help='maximum number of concurrently running threads; ' \
                      'the default is 10', type='int', default=10,
                      metavar='SIZE')
    
    parser.add_option('-q', '--socket-queue-size', dest = 'socket_queue_size',
                      help = 'the SIZE of the socket queue; the default ' \
                      'is 5', type = 'int', default = 5,
                      metavar = 'SIZE')
    
    parser.add_option('-l', '--listen-mode', dest = 'listen_mode',
                      help = 'Listen for inbound connections',
                      action = 'store_true', default = False)
    
    parser.add_option('-t', '--test', dest = 'test_mode',
                      action = 'store_true', default = False,
                      help = 'run in looping test-mode')
    
    #parser.add_option('-d', '--no-daemon', dest = 'daemon',
    #                  action = 'store_false', default = True,
    #                  help = 'don\'t run as a daemon process')

    parser.add_option('-T', '--phone-number', dest = 'phone_number',
                      default = None, help = 'the number that the message ' \
                      'supposedly was sent from; deault is None',
                      metavar = 'PHONE')
    
    parser.add_option('-i', '--input-file', dest = 'input_file',
                      default = None, help = 'Read input from FILE',
                      metavar = 'FILE')

    parser.add_option('-f', '--log-file', dest = 'log_file',
                      default = '%s.log' % basename,
                      help = 'store the log in FILE; the default is ' \
                      '\'%s.log\'' % basename, metavar = 'FILE')
    
    parser.add_option('-L', '--log-level', dest = 'log_level',
                      default = 'info',
                      help = 'the filter LEVEL used when logging; possible ' \
                      'values are ' \
                      'DEBUG < INFO < WARNING < ERROR < CRITICAL; the ' \
                      'default is INFO' , metavar = 'LEVEL')
    
    parser.add_option('-w', '--web', dest = 'web',
                      help = 'generate output suitable for the Web; ' \
                      'this implicates --transaction-id=WEB',
                      action = 'store_true', default = False)

    parser.add_option('-W', '--show-technical', dest = 'show_technical',
                      help = 'show technical information (semantics)',
                      action = 'store_true', default = False)
    
    # Parse the command line.
    
    options, args = parser.parse_args()

    if options.web:
        options.trans_id = 'WEB'
        
    # Expand the any paths and make them absolute.
    
    options.log_file = os.path.abspath(os.path.expanduser(options.log_file))
    
    # Create a mapping between the user-supplied log level string and
    # the constants define by the logging module.
    
    log_levels = dict([(logging.getLevelName(l).lower(), l)
                       for l in [logging.DEBUG, logging.INFO, logging.WARNING,
                                 logging.ERROR, logging.CRITICAL]])
    
    options.log_level = log_levels[options.log_level]
    
    return options, args


def run_listening_server(options):
    
    import signal
    
    import TTP.Handler
    import TTP.Server
    
    # Create a server which will use a TUC Transfer Protocol Handler.
    
    server = TTP.Server.BaseThreadingTCPServer((options.ip_address,
                                                options.port),
                                               TTP.Handler.BaseHandler,
                                               options.log_file,
                                               options.log_level,
                                               options.high_load_limit,
                                               options.socket_queue_size)

    # In Python, when the `signal' module is available, interrupts
    # always go to the main thread.
    #
    # Register a signal handler for the hang-up signal.
    
    signal.signal(signal.SIGHUP, server.hangup)
    
    # Register signal handlers for terminating signals.

    signal.signal(signal.SIGINT, server.shutdown)
    signal.signal(signal.SIGTERM, server.shutdown)

    server.serve_forever()
    

def run_single_test(m, options, parser):
    
    try:
        meta, body = TTP.Message.communicate(m, (options.ip_address,
                                                 options.port), parser)
    except:
        meta, body = None, 'An error occured. Service currently not available.'
        return meta, body
    
    if options.web:

        b = TTP.Message.build(body, parser)
        
        if options.show_technical:
            body = '<tt>%s</tt><hr>%s<hr>' % (b.TUCAns.Technical,
                                                b.TUCAns.NaturalLanguage)
        else:
            body = b.TUCAns.NaturalLanguage
            
    return meta, body.encode('latin-1')


def run_test_mode(m, options, parser, pre_msg):
    
    f = open(options.input_file, 'r')

    for i, line in enumerate(f):

        m.MxHead.MsgId = i
        m._setMessage('%s%s' % (pre_msg, line))

        meta, body = run_single_test(m, options, parser)
        print '%d: %s\n%s' % (i, meta, body)
        
        time.sleep(3)

    f.close()

        
def main():
    
    """ Module mainline (for standalone execution) """
    
    options, args = parse_command_line()
    
    if options.listen_mode:
        
        run_listening_server(options)
        
    parser = xml.sax.make_parser()
    parser.setContentHandler(TTP.Message.XML2Message())
    
    m = TTP.Message.MessageRequest()
    m.MxHead.TransId = options.trans_id
    if options.phone_number:
        m.MxHead.ORName = options.phone_number
        
    if options.trans_id == 'LINGSMSOUT':
        pre_msg = 'TEAM '
    else:
        pre_msg = ''
    
    if options.test_mode:

        if not os.access(options.input_file, os.R_OK):
            print "You have to supply a path to a readable " \
                  "test-input file.\n" \
                  "The current value, '%s', is not a readable file." \
                  % (options.input_file)
            sys.exit(1)
            
        run_test_mode(m, options, parser, pre_msg)
        
    else:

        # Request a single (non-alert) answer (as from a Web page).
        
        m.MxHead.MsgId = -1
        m._setMessage('%s%s' % (pre_msg, args[0]))
        
        meta, body = run_single_test(m, options, parser)
        
        if options.log_level == logging.DEBUG:
            print '%s\n%s' % (meta, body)
        else:
            print '%s' % (body)
            
    return

if __name__ == "__main__":
    main()
    
